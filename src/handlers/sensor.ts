import { APIGatewayProxyEvent } from 'aws-lambda';
import { DynamoDB } from 'aws-sdk';
import 'source-map-support/register';
import { v1 as uuidV1 } from 'uuid';

import { crudReturnInter } from './crudInterface';
import { logError, logSuccess } from '../utils/logs';

// retrieve env vars generated by ssm plus stage context
const { TableName, IS_OFFLINE } = process.env;

// set dynamo client according stage context
const dynamo = new DynamoDB.DocumentClient(
  IS_OFFLINE
    ? {
        region: 'localhost',
        endpoint: 'http://localhost:8000', // hardcoded here but we can also set it as a ssm key
      }
    : {}
);

/**
 * Create a new item
 * @param event
 */
const create = async (event: APIGatewayProxyEvent): Promise<crudReturnInter> => {
  try {
    const itemId = uuidV1();
    const timestamp = new Date().toISOString();
    const { content } = JSON.parse(event && event.body);

    // Add an item to dynamoDB
    await dynamo
      .put({
        TableName,
        Item: {
          itemId,
          content,
          createdAt: timestamp,
          updatedAt: timestamp,
        },
      })
      .promise();

    return logSuccess({
      message: `Item ${itemId} created at ${timestamp}`,
    });
  } catch (error) {
    return logError(error);
  }
};

/**
 * List all items
 */
const list = async (): Promise<crudReturnInter> => {
  try {
    // List all items
    const { Items } = await dynamo
      .scan({
        TableName,
      })
      .promise();

    return logSuccess({
      Items,
      message: `${Items.length} items retrieved`,
    });
  } catch (error) {
    return logError(error);
  }
};

/**
 * Read one item
 * @param event
 */
const read = async (event: APIGatewayProxyEvent): Promise<crudReturnInter> => {
  try {
    const itemId = event && event.pathParameters && event.pathParameters.itemId;

    // retrieve one item by the itemId
    const { Item } = await dynamo
      .get({
        TableName,
        Key: {
          itemId,
        },
      })
      .promise();

    if (!Item) {
      throw `Item ${itemId} unknown`;
    }

    return logSuccess({
      Item,
      message: `Item ${itemId} retrieved`,
    });
  } catch (error) {
    return logError(error);
  }
};

/**
 * Remove one item
 * @param event
 */
const remove = async (event: APIGatewayProxyEvent): Promise<crudReturnInter> => {
  try {
    const itemId = event && event.pathParameters && event.pathParameters.itemId;

    // delete one item by the itemId
    await dynamo
      .delete({
        TableName,
        Key: {
          itemId,
        },
      })
      .promise();

    return logSuccess({
      message: `Item ${itemId} deleted`,
    });
  } catch (error) {
    return logError(error);
  }
};

/**
 * Update one item
 * If not exists we return an error
 * @param event
 */
const update = async (event: APIGatewayProxyEvent): Promise<crudReturnInter> => {
  try {
    const itemId = event && event.pathParameters && event.pathParameters.itemId;
    const timestamp = new Date().toISOString();

    const { content } = JSON.parse(event && event.body);

    const { statusCode } = await read(event);
    if (statusCode === 400) {
      throw `Item ${itemId} unknown`;
    }

    // update one item by the itemId
    await dynamo
      .update({
        TableName,
        Key: {
          itemId,
        },
        ExpressionAttributeValues: {
          ':content': content,
          ':updatedAt': timestamp,
        },
        UpdateExpression: 'SET content = :content, updatedAt = :updatedAt',
        ReturnValues: 'ALL_NEW',
      })
      .promise();

    return logSuccess({
      message: `Item ${itemId} updated at ${timestamp}`,
    });
  } catch (error) {
    return logError(error);
  }
};

export { create, list, read, remove, update };
